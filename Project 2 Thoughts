Step 1 - create a link state packet, it says that a linkstate packet will use a normal packet header, does this mean an IP header? in the networking book it seems that they use an entirely different type of header for their examples. Need to find the maximum size i can transmit at once so i can figure out how to effectively store the link state information.

step 2 - flood the LSP's. one of the requirements for this protocol is reliable flooding, but the implementation from project 1 does not use any acknowledgements, should we add this on top of the project 1 flooding implementation, and if so would that mean we would need to add a new protocol for Link State Acknowledgement packets? also for flooding in project one its all done through sends and its not like you can say send a packet to one person or flood a packet, not so much at least, and I didnt implement my project1 to be able to have a message sent to everyone in the network, it floods through everyone but only the dest treats it as received, i use the broadcast addr to designate its a neighbor discovery packet in which case it does not flood it. Also it says the exception of forwarding is link state information and neighbor discovery, and to flood these packets, We're supposed to flood neighbor discovery packets? OOH WAIT if TTL = 1 when you send it out at first even if it isnt given a special case not to flood it wont! i hope thats how its supposed to work. The book also said that packets should not be broadcasted back to the previous sender, does this mean we should do a set of individual sends to each neighbor on the neighbor list except the previous node that sent the packet, or should we continue to use broadcast and have the source drop the packet.

do we need to represent the path costs in the lists or should we assume they're all 1, im pretty sure they're all 1, 0 or infinity so those numbers could be assumed by the pathfinding algorithm, but if those numbers are subject to change i need to know what numbers to use to represent the node is self(0?) and the node is not connected(infinity, but how to represent). And all of this has to be done inside of 20 bytes, 8 bits per entry. And thats just to support a 20 node network. Actually in retrospect, we dont have to store the node ID in the field, because that could be represented by the index for our implementation. Should we use the index to represent the node and the data @ the index to represent the connectivity of the node?


side note, i made an array to store my link state information and i was making sure it all checked out with the assumption that it all started at 0, so if it was connected i set it to 1, if it wasnt i set it to 0xff , and if it was me i left it alone (should stay 0), i then read back the values to find that it was getting set to 0x14. somehow i was getting dirty memory in this array, but my neighborlist, which also assumes all values in the array default to 0 has never had such an issue.

should i make a new send function that contains all the code that either forwards or broadcasts the message, i could make a forward function (which would retrieve data from the list of nexthops and then call sendbufferpushback with the appropriate neighbor) and just continue to implement flooding via the actual sendbufferpushback method. or i could just make it forward when it should forward and broadcast when it should broadcast. Doesnt seem robust to do it that way.

make a map uint8_t[20][20] 20 lists of 20 node connection states per node

make a list to store next hops, each entry should have (destination, cost, nextHop) dest would be the index, cost would be the sum of the connection costs for all the nodes in the path, next hop will be the node that is directly connected to source that the packet should be sent to.

implement dijkstra's alg, this should update a list of next hops

the nodes need to track the sequential age of their currently used Link States, so this must be a part of the list, which for my implementation is currently the map as well if you can really call it a map. I cannot send the entire link state info inside of the payload of a packet, so i must extract the links array and put it into the payload and the sequential age and put that as the sequence number for the packet.

consider switching back to a list of nodes, as opposed to an array, poping and pushing is more conceptual.
Store neighbors as a list, in numerical order
how do i send this list over a packet?
all costs are assumed 1
would need to adjust nodeList to fit into a packet, or increase the maximum payload size of a packet. Justification for making nodeList length 19, all other variables in tiny os that limit the number of nodes are set to 20, and a node cannot be its own neighbor, so you can have at most 19 neighbors, leaving room for the last byte to count the number of connected neighbors

implementing link reliability estimation - Utilize neighbor discovery since it is already constantly sending packets and wont increase the traffic. Every time you send you say sent, once it times out you say not received. you have a list of N packets, kept up to date for the most recent packets recieved / missed over each link. If you skip some packets you assume every packet since the last hit is a miss. pop the old from the front push the new on the back. you can also re adjust the average based on the values coming out and going in instead of recalculating the entire sum each time. Every time you broadcast an LSP packet you also broadcast a the estemated reliability for each link. Path cost is chosen to have the highest probabilty of success, so sending over two 90% probability links gives you 81% chance of success, sending over an 80% and a 100% gives you 80, so you chose the path through the two 90% links. neighbor discovery will have to have its own sequence number to accurately estimate which packets you dropped. Probability of a drop will probably half the drop rate, since the discovery packets must travel the path in both directions.

how do i send the link reliability to other nodes. 

the one way link reliability can be measured fairly acurately by referencing the sequence numbers of your neighbors discovery broadcasts, that is, whenever you receive a neighbor discovery packet of type ping (the neighbor is trying to discover you) you check its sequence number and the sequence number of the last broadcast you received from them, if it is more than 1 appart then you assume every message between previoius and current was dropped and you record it as a miss. you then add the current as a hit,

I want each cost to start at 1 and increase based on the lossyness of the link.   1 + (drop count / 4) = (1-9) is an example. Or get the success rate of each link and multiply them together and chose the path with the highest probability of transmission.
