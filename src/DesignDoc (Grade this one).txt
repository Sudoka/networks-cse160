John Lusby
CSE 160 Computer Networks
Project 1
9-18-2012

Design Documentation

I'm sorry this is so long. I've never been a good writer but I got really into this project and this class so I ended up going pretty indepth, cut out as much as I could.

Flooding -
I implemented flooding utilizing the IP header, physical layer broadcast, and a list of entries that identify handled packets. The first step of my implementation was to get packets forwarding from one node to another node that it is not directly connected to.  When each of the neighbors receives the packet they first check if the message is one they have already received. If so they exit and return the message and print a relevant debug statement, if not they add it to the list of received packets then continue. Next the node goes through the following logic steps, if the destination me, receive, else if the source is me discard, else forward. Forwarding is done by making an exact copy of the packet from the ip layer down which is then physically sent to the broadcast address (its neighbors).  In a perfect run (no packets collide) every node will receive the message once per neighbor they have and will forward on the first receive and discard every subsequent copy it receives.
Flooding Decisions-
1) How to handle the received list - I did this using the arrList data structure provided by the skeleton code. This creates an array[30] of pairs, which contain a source and a sequence number. Whenever a packet is received it is checked if it is already contained in the list, if it isn’t a new entry containing the source and sequence of the packet is added to the back of the list, if it is on the list it immediately discards the packet and does not continue on the receive function. When I reach maximum capacity on the list I pop the front (oldest) entry and add the new entry to the back. 

Neighbor Discovery-
I implemented neighbor discovery using the destination address in the header as an identifier, physical broadcast sends, ping and ping reply case statements, a timer for the discovery broadcasts, and 2 different lists for the received packets. The first step in neighbor discovery was to be able to come up with a packet type that would be easily identified as a neighbor Discovery packet. I chose to use the broadcast address as the destination because assumedly you will never be sending to a node with the broadcast address as the ID and it seemed better than using a special payload which could easily be faked. Next I wrote a function called discoverNeighbors() which when called will create a packet with protocol ping and destination DISCOVERY_DEST, which I initialized to AM_BROADCAST_ADDR, it then calls sendBufferPushBack using its id as the source and the broadcast address as the destination. I then added a 4th logic step to my receive function which checks if the destination is equal to the DISCOVERY_DEST. If it is then it will check if the protocol is a ping or a ping reply. If it is a ping reply the node knows that one of its neighbors is trying to discover it so it creates a ping response, still keeping the IP header destination as DISCOVERY_DEST but changing the header source to its source and the protocol to a ping reply. The node then does a physical send directly back to the source of the ping packet. If a the packet received in the discovery if statement has a protocol of ping reply it knows that the sender must be its neighbor, so it adds this neighbor to its list of neighbors. In order to implement this list of neighbors I used two different lists, the first one is a simple array of uint16_t's where each index represents a node id of a possible neighbor and each value is the time the node last received a packet from that neighbor. Each time a packet is received from a neighbor node it gets the current time and adds inputs it as the value @ index of the neighbor’s tos_node_id. I then have two other functions and one other list. updateNeighbors which turns this temporary list of most recent received packets to an array list of node ID's of connected neighbors and printNeighbors which will just loop through this list and print debug statements to show who my current neighbors are. 
Neighbor discovery decisions
1) broadcast addr in dest as identifier -The only thing that worries me with this approach is that there may be a time where a message should be received by all nodes in which case you might want to use the broadcast address as the destination, if that ever becomes an issue I can also use a special payload and a string compare, a TTL outside of the normal range, a sequence number that doesn’t exist, or I send an entirely different packet or no packet and utilize the Ethernet header information in message_t in order to figure out the source and respond appropriately. There are many different ways to implement this; I choose the one that I figured was the simplest effective method. 
2) Two list approach - I decided to use this method because I felt that having a single list that is cleared every time I call my discovery timer (which seems to be the plan of most people) would result in a list that is too unreliable. The worst case scenario I imagine is this, I have a few sends already waiting to go out on the buffer, I then call my discoverNeighbors function and delete my list then queue a broadcast message to discover neighbors, then one of the other sends that is in the queue ahead of the neighbor discovery packet tries to access the list of neighbors only to find that it has no neighbors. This could have major impact in the code and change how it is written (if the list is randomly empty then you have to flood your message, or something like that) With the way I implemented it the list that keeps track of neighbor discovery responses and the list of neighbor node id's are not physically connected, and at any time I can update the arraylist of neighbors based on the responses I have most recently received without having to wait on any send -> reply's. I could have my node only call update neighbors function only when it needs to send so the list is not constantly updating when it isn’t needed. Currently though I have it update the list every time a neighbor reply packet is received, so once per neighbor per discovery send.

