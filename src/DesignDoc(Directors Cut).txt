John Lusby
CSE 160 Computer Networks
Project 1
9-18-2012

Design Documentation

Flooding -
I implemented flooding utilizing the IP header, physical layer broadcast, and an arrList of entries that identify handled packets. The first step of my implementation was to get a packet forwarding from one node to another node that it is not directly connected to. In order to do this my code first constructs a packet and stores the final destination, original source, and sequence number of the packet relative to the sender in the IP header (packet.h). It then uses the physically broadcasts the packet to all its neighbors using sendBufferPushBack. When each of the neighbors receive the packet they first check if the message is one they have already received. If so they exit and return the message and print a relevant debug statement, if not they add it to the list of received packets then continue. Next the node goes through the following logic steps, if the destination me, receive, else if the source is me discard, else forward. In order to forward the packet the node makes an exact copy of the packet from the ip layer down, copying the header and payload that it received and tells its physical hardware to broadcast it to all of its neighbors, for the physical sendBufferPushBack send it uses its own Node ID as the source and the Broadcast address as the destination. When the message is received if I wanted to check the source I would check the physical layer (ethernet?) header information in the message_t, rather than the IP header in pack. In a perfect run (no packets collide) every node will receive the message once per neighbor they have and will forward on the first receive and discard every subsequent copy it receives.
Flooding Decisions-
1) how to handle the received list - I did this using the arrList data structure provided by the skeleton code. This creates an array[30] of pairs, which contain a source and a sequence number. Whenever a packet is received it is checked if it is already contained in the list, if it isnt a new entry containing the source and sequence of the packet is added to the back of the list, if it is on the list it immediately discards the packet and does not continue on the receive function. When I reach maximum capacity on the list I pop the front (oldest) entry and add the new entry to the back. There was an issue with neighbor discovery where if I did not control how which packets were being recorded the neighbor discovery packets would quickly fill up the entire list and though this did not prevent my code from functioning it seemed unnecessary to record neighbor discovery related packets since they are completely seperate from flooding, so there is an external if statment that will tell it to skip the list check and add if the packet is a discovery type packet.

Neighbor Discovery-
I implemented neighbor discovery using the destination address in the header as an identifier, physical broadcast sends, ping and ping reply case statements, a timer for the discovery broadcasts, and 2 different lists for the received packets. The first step in neighbor discovery was to be able to come up with a packet type that would be easily identified as a neighbor Discovery packet. I chose to use the broadcast address as the destination because assumably you will never be sending to a node with the broadcast address as the ID and it seemed better than using a special payload which could easily be faked. Next I wrote a function called discoverNeighbors() which when called will create a packet with protocol ping and destination DISCOVERY_DEST, which i initialized to AM_BROADCAST_ADDR, it then calls sendBufferPushBack using its id as the source and the broadcast address as the destination. I then added a 4th logic step to my receive function, after it has the node is the source or the destination and before it assumes its ment to be forwarded it checks if the destination is equal to the DISCOVERY_DEST. If the packet is a discovery packet then it will check if the protocol is a ping or a ping reply. If it is a ping reply the node knows that one of its neighbors is trying to discover it so it creates a ping response, still keeping the IP header destination as DISCOVERY_DEST but changing the header source to its source and the protocol to a ping reply. The node then does a physical send directly back to the source of the ping packet, it does not broadcast its reply despite having the ip header dest set to broadcast, if a the packet received in the discovery if statement has a protocol of ping reply it knows that the sender must be its neighbor, so it adds this neighbor to its list of neighbors. In order to implement this list of neighbors i used two different lists, the first one is a simple array of uint16_t's where each index represents a node id of a possible neighbor and each value is the time the node last received a packet from that neighbor. Each time a packet is received from a neighbor node it gets the current time and adds inputs it as the value @ index of the neighbors tos_node_id. I then have two other functions and one other list. The most important function is the updateNeighbors function which turns this temporary list of most recent received packets to an array list of node ID's of connected neighbors, whenever update neighbors is called it erases the content of the neighbor array list and loops through each index of the neighbor ping response array, if the time in the value index is != 0 and it is not more than a timeout (in this case 10x the frequency of the discovery timer) less than the current time, it assumes it is currently connected to the node and pushes it onto the list of neighbors, if the timer is 0 the node has never been connected and if the difference between the current time and the last time received is greater than the timeout it assumes the neighbor has been droped or disconnected. I then have another function printNeighbors which will just loop through this list and print debug statements to show who my current neighbors are. 

neighbor discovery decisions
1) broadcast addr in dest as identifier -The only thing that worries me with this approach is that there may be a time where a message should be received by all nodes in which case you might want to use the broadcast address as the destination, if that ever becomes an issue i can also use a special payload and a string compare, a TTL outside of the normal range, a sequence number that doesnt exist, or i send an entirely different packet or no packet and utilize the ethernet header information in message_t in order to figure out the source and respond appropriately. There are many different ways to implement this, i choose the one that i figured was the simplest effective method. 
2) two list approach - I decided to use this method because I felt that having a single list that is cleared every time i call my discovery timer (which seems to be the plan of most people) would result in a list that is too unreliable. The worst case scenario i imagine is this, I have a few sends already waiting to go out on the buffer, i then call my discoverNeighbors function and delete my list then queue a broadcast message to discover neighbors, then one of the other sends that is in the queue ahead of the neighbor discovery packet tries to access the list of neighbors only to find that it has no neighbors. This could have major impact in the code and change how it is written (if the list is randomly empty then you have to flood your message, or something like that) With the way i implemented it the list that keeps track of neighbor discovery responses and the list of neighbor node id's are not physically connected, and at any time i can update the arraylist of neighbors based on the responses i have most recently received without having to wait on any send -> reply's. I could have my node only call update neighbors function only when it needs to send so the list is not consantly updating when it isnt needed. Currently though i have it update the list every time a neighbor reply packet is received, so once per neighbor per discovery send.
